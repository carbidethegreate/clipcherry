CLIPcherry Technical Architecture

This document provides an overview of CLIPcherry’s system architecture and how its components interact. The platform is designed as a collection of cloud-based services centered around a Cloudflare edge application, which together enable creators to upload content, supporters to purchase access via crypto, and everyone to experience fast content delivery worldwide.
Overview

At a high level, CLIPcherry follows a serverless, edge-first architecture. There is no traditional monolithic server or centralized data center; instead, the application is distributed across Cloudflare’s global network. The core of the system is a Cloudflare Worker that acts as the application server (handling API requests, business logic, and integration with other services). Surrounding this core are managed services for data storage, media handling, and payments. This architecture yields several benefits:
Global Low Latency: By running code at Cloudflare’s edge locations, user requests (page loads, API calls) are handled by a data center geographically close to the user, minimizing response times.
Scalability: The use of serverless components means the platform can scale automatically. During high traffic or content demand, Cloudflare simply runs more instances of the Worker and utilizes its network capacity—no manual scaling is needed.
Modularity: Each aspect of the platform (database, storage, media, payments) is handled by a specialized service. This separation of concerns makes the system easier to manage and more robust, as each component can be updated or scaled independently.
Key Components

The CLIPcherry architecture consists of several key components and services working together:
Cloudflare Worker (Edge Application Backend)
The Cloudflare Worker is the central hub of the architecture. It’s a serverless function deployed to Cloudflare’s edge that serves as the backend API and controller for the platform. The Worker handles incoming HTTP requests from users’ browsers:
Routing & APIs: It routes requests to different functionality (for example, fetching a list of content, handling a login, or initiating a purchase). Each route is implemented in the Worker’s code, essentially acting like a lightweight web framework at the edge.
Business Logic: The Worker contains the logic for enforcing rules—checking if a user is authorized to view a particular image or video, processing a new content upload, or verifying a crypto payment.
Integration: It communicates with other services (D1, KV, Images, Stream, etc.) using their APIs or SDKs. For instance, when a new image is uploaded via the front-end, the Worker will call Cloudflare Images API, and when a purchase is made, it will query the database and potentially call a blockchain API.
Security Checks: Since the Worker sits between the user and the data, it also enforces security (e.g., ensuring a user is logged in or owns the content before delivering the unblurred version).
This Cloudflare Worker is stateless (it doesn’t maintain persistent in-memory sessions between requests). This stateless design allows any Cloudflare edge node to handle any request, with consistency ensured by the shared database and caches.
Cloudflare D1 (Database)
Cloudflare D1 is the primary data store in the architecture. It’s used as a relational database for persistent information:
Data Stored: D1 tables likely include users (creator and supporter accounts), content listings (with details like title, description, price, media ID references), purchase records (which user bought which content and when), and possibly audit logs or other metadata.
Usage: The Worker queries D1 for dynamic content. For example, when a supporter browses available clips, the Worker runs a D1 query to fetch all content that is published by creators. When a purchase is confirmed, the Worker updates a purchase/entitlement record in D1 to note that the supporter now has access to that content.
Migrations: The presence of a /schema directory in the repository indicates that database schema migrations are managed (likely through SQL migration files). This ensures the database structure evolves in a controlled way as the application grows.
Consistency: While D1 is distributed, it provides eventual consistency across the globe. In practice, Cloudflare will handle replicating data. The platform design likely tolerates the slight delay in replication (which is typically short), given the benefit of wide availability.
Cloudflare KV (Caching Layer)
Cloudflare KV acts as a high-speed, globally replicated cache or simple key-value store:
Session/Token Cache: If CLIPcherry uses session tokens or similar, KV could store these for quick verification without hitting the database. Likewise, API rate limiting counters or ephemeral feature flags could live in KV.
Configuration and Content Cache: Some relatively static or frequently read data (like a homepage list of featured creators, or site configuration settings) might be stored in KV so that the Worker can retrieve it with minimal latency.
Edge Caching: KV is particularly useful for data that isn’t constantly changing. By caching such data in KV, the Worker reduces load on D1 and speeds up responses. KV’s eventual consistency model is acceptable for data that isn’t highly dynamic (e.g., it’s fine if a new piece of content appears in the cache a few seconds after being written to the database).
Cloudflare Images (Image Storage and Delivery)
Cloudflare Images is utilized for storing and delivering image files:
Upload Process: When a creator uploads an image (for example, a photo or a cover image for a video), the file is sent from the client to the backend (or potentially directly to a Cloudflare endpoint). The Worker likely receives the image file (e.g., via an HTTP POST in a form submission) and then calls the Cloudflare Images API to store it. Cloudflare Images returns a unique image identifier (such as 917d2a53-...-d8b1e5ad7800).
Storage & CDN: The image is stored in Cloudflare’s optimized image storage and made available via their CDN. The architecture doesn’t require a separate image server; Cloudflare handles replication and caching of images globally.
Access Control: By default, an image stored in Cloudflare Images might be publicly accessible via its ID. CLIPcherry likely ensures that image URLs are not exposed until purchase. This could be done by requiring image requests to go through the Worker (which checks if the user has purchased the content) or by using signed URLs/variants for images. For instance, the Worker could serve a blurred variant of an image for previews and only serve the original image (or a high-res variant) after purchase.
Advantages: Using Cloudflare Images simplifies media handling, offloading image resizing, format conversion, and delivery to Cloudflare’s infrastructure. It ensures even large images load quickly for users by serving them from a nearby location and in an optimized format/size.
Cloudflare Stream (Video Hosting and Streaming)
Cloudflare Stream integrates a video pipeline into the architecture:
Upload & Encoding: Similar to images, when a creator uploads a video, the file is either sent via the Worker or directly to Cloudflare Stream’s API (with the Worker coordinating the process). Once uploaded, Cloudflare Stream handles encoding the video into multiple resolutions and formats for adaptive streaming.
Video ID & Storage: Cloudflare Stream provides an identifier or a playback embed code for each video. The Worker stores this ID in the D1 database as part of the content record. The actual video content is stored on Cloudflare’s servers.
Streaming Delivery: When a supporter chooses to watch a purchased video, the front-end might use the Cloudflare Stream player or request a streaming URL via the Worker. Stream will deliver the video in an optimal streaming format (HLS/DASH) with adaptive bitrate, ensuring smooth playback on various devices and network conditions.
Access Control: CLIPcherry must ensure that videos are only playable by authorized users. Cloudflare Stream allows restricting video streams (for example, via signed tokens or domain restrictions). The Worker could generate a short-lived signed URL for the video stream when a supporter has purchased the content. Alternatively, the front-end might embed a Stream player that is gated until the user is verified. The key is that without going through the platform’s checks, a video URL alone shouldn’t grant access.
Efficiency: Incorporating Cloudflare Stream means CLIPcherry doesn’t need any separate media servers or complex video processing workflows. This keeps the system architecture simpler and leverages Cloudflare’s robust video delivery network.
Blockchain Networks (XRP Ledger and Bitcoin)
Unlike the other components, the blockchain networks are external systems that CLIPcherry interfaces with for payment transactions:
XRP Ledger: The Worker connects (through an API or SDK) to the XRP Ledger to monitor or send transactions. For example, when a supporter opts to pay in XRP, the platform might provide an address (and possibly a unique destination tag) for the payment. The Worker then awaits a payment to that address. This could involve periodically checking an XRP ledger API for the transaction’s confirmation. After confirmation, CLIPcherry can credit the payment and perhaps forward the received XRP to the creator’s wallet or an internal pool.
Bitcoin Network: For Bitcoin, the platform uses an extended public key (XPUB) to derive unique deposit addresses. The Worker uses this XPUB to generate a new Bitcoin address for each purchase and records it. Once the supporter sends BTC to that address, the Worker monitors a blockchain explorer API or service for that address to receive the payment. After the necessary confirmations, it marks the payment as received in the system.
Security and Handling: Private keys for crypto (like the XRP secret) are kept securely as environment secrets so they are never exposed. The use of an XPUB for Bitcoin means the platform can generate addresses on the fly without storing the actual private keys on the server, which is a security best practice.
Payouts: The architecture could allow automatic payouts to creators in crypto. For instance, the platform might accumulate a creator’s earnings and then use the XRP secret to send an XRP payment to the creator’s wallet address on a set schedule or when they request a withdrawal. Similarly, Bitcoin payouts could be done manually or via a separate process, since sending BTC from cold storage often involves additional security steps.
Content Upload and Management Flow

When a creator uploads new content, multiple components interact in sequence:
Frontend Submission: The creator uses the CLIPcherry web interface to fill in content details (title, description, price, etc.) and select a media file (image or video) to upload.
Worker API Call: The front-end makes an API request to the Cloudflare Worker (for example, a POST /api/content/create) including the form data. The media file might be directly included in this request or handled in a separate step (some architectures use a two-step process for large file uploads: first get a special upload URL or token from the server, then upload the file to that URL).
Image/Video Handling: If the upload is an image, the Worker forwards the file to Cloudflare Images for storage. If it’s a video, the Worker initiates an upload to Cloudflare Stream. The Worker receives back an ID or URL from these services once the upload is successful.
Database Update: The Worker creates a new content record in the D1 database. This record includes all metadata (title, creator ID, price, etc.), plus the returned media identifier (image ID or video ID). The content is marked as available for purchase but initially no supporter has access.
Confirmation to Frontend: The Worker responds to the creator’s request confirming that the content was created successfully. The new content now appears in the creator’s list of items (e.g., via another API call that fetches the creator’s content list from D1).
Post-Upload Processing: Cloudflare Stream might still be processing a video in the background (for large videos, encoding can take some time). If so, the Worker could handle a callback or webhook from Cloudflare Stream when the video is ready to stream. Upon such a callback, the Worker would update the content record (e.g., set a “video_ready” flag). For images, processing is minimal and images are typically ready to serve immediately, aside from any background optimization Cloudflare does.
Throughout this flow, error handling is important (for example, if an upload fails or a network issue occurs during file transfer, the Worker should notify the front-end and allow the creator to retry, and partially created records should be cleaned up or marked incomplete). Because the actual heavy lifting (storing the file data) is done by Cloudflare services, the Worker mainly coordinates and records information, keeping the process efficient and scalable.
Purchase and Content Access Flow

When a supporter decides to purchase content, the system ensures a secure transaction and then grants access:
Initiating Purchase: On the front-end, when a supporter clicks a “Buy” or “Unlock” button for a piece of content, the app sends a request to the Worker (e.g., POST /api/purchase) with the content ID and the user’s identity (the user must be logged in).
Generate Payment Details: The Worker looks up the price of the content (from D1) and determines the payment method. It then generates payment instructions for the supporter:
For XRP: It provides the XRP wallet address (and a unique destination tag or memo, if using one wallet for multiple transactions) where the payment should be sent. The exact amount of XRP required is specified.
For BTC: It uses the XPUB to derive a fresh Bitcoin address for this transaction. It records this address (and the expected BTC amount) in D1 or KV along with an expiration time for the payment.
Respond to Frontend: The Worker responds with the payment details (for example, a JSON containing the address, amount, and perhaps a QR code image URL or payload). The front-end then displays instructions to the supporter on how to complete the payment using their crypto wallet.
User Sends Payment: The supporter sends the cryptocurrency from their wallet to the provided address. The front-end may show a waiting indicator or countdown while it waits for confirmation. (For XRP, confirmation might be a few seconds; for Bitcoin, it could be several minutes depending on network fees and required confirmations.)
Payment Monitoring: The Worker (on the back-end) monitors for the incoming payment. This can be done by:
Polling: The front-end could periodically call a “payment status” endpoint (e.g., GET /api/purchase/status?transactionId=X) which the Worker checks to see if the payment has been received/confirmed.
Webhook/Callback: Alternatively, if using a third-party service or Cloudflare Workers Cron Triggers, the system could periodically check the blockchain for that specific address/transaction.
In practice, a simple polling from the client or short-interval worker cron job can check the status every few seconds.
Confirm and Record Payment: Once the payment is detected on the blockchain and meets any confirmation requirements, the Worker marks the purchase as complete. This means updating D1 (or the relevant database) to record that user X has purchased content Y. It might also store transaction details like transaction hash and timestamp for record-keeping.
Unlock Content: The supporter’s account is now authorized to access the content. The next time the supporter requests the content:
If they attempt to view an image, the Worker will now allow serving the original image (or the front-end, knowing the purchase is complete, will load the unblurred image from Cloudflare Images).
If it’s a video, the front-end can now load the Cloudflare Stream player or link for the full video. The Worker might provide a secured playback token if needed.
In the user interface, the previously blurred image now appears clear, and video playback controls become available.
Content Delivery: The actual delivery of the media occurs through Cloudflare’s infrastructure (Images or Stream). Since the user is now authorized, the experience is seamless — images load in full quality and videos stream in the player. All of this is done without requiring a page refresh (in a single-page app, the UI would simply update).
Post-Purchase Actions: The platform could optionally notify the creator of the sale (e.g., increment a sales counter, send a notification or email to the creator saying “Congrats, your content was purchased!”). This would be handled asynchronously, perhaps by a separate Worker function or an event in D1 that the creator’s dashboard picks up.
The purchase flow shows how the platform bridges the on-chain world with the web application. Even though blockchain transactions might introduce a bit of waiting, the user experience is managed carefully by the front-end and back-end working together (providing feedback like “Awaiting payment confirmation…”). Importantly, all access control is enforced by the backend: even if someone tried to bypass the UI, the Worker will not serve the unblurred content or a valid video stream unless the purchase record exists.
Additional Considerations

User Accounts and Authentication: While not detailed in this summary, CLIPcherry likely has an authentication system (so that users can log in as a creator or supporter). This could be implemented via JWT tokens, sessions stored in KV, or using OAuth if integrating third-parties. The architecture would include endpoints for login, logout, and account management, all handled by the Worker. Authentication is critical to ensure that purchase records tie a specific user to content access, and the Worker would verify these credentials on each request.
Deployment and CI/CD: The entire platform (Worker code, front-end assets, and perhaps database migrations) can be deployed through Cloudflare’s pipeline. Using Wrangler, developers can publish updates to the Worker script and upload new assets. The architecture might use multiple environments (e.g., a staging environment with a separate Worker and D1 database) so new features can be tested before going live. Since all services (D1, Images, Stream) are managed, deployment mainly involves updating configurations and pushing code, rather than provisioning servers.
Monitoring and Logging: Cloudflare Workers provide logs and metrics, which are important for observing the system in production. The architecture likely relies on Cloudflare’s built-in logging or an external aggregator (via Logpush or API) to track usage, performance, and errors. Additionally, blockchain transactions can be monitored via their respective explorers. Cloudflare’s dashboard would also show usage stats for Images and Stream, helping the team ensure that the media usage stays within plan limits or performance expectations.
In summary, CLIPcherry’s technical architecture is designed to maximize performance and reliability by leveraging Cloudflare’s edge network and managed services, while also integrating with decentralized payment systems. The result is a platform that can serve a global user base with minimal latency, handle rich media content seamlessly, and facilitate secure, trustless transactions between supporters and creators.
